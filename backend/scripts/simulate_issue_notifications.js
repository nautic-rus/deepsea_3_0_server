#!/usr/bin/env node
// Simulate createIssue notification flow for a given project_id (defaults to 1)
// Usage: node scripts/simulate_issue_notifications.js [projectId]

const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '..', 'env') });

const UserNotificationSetting = require('../src/db/models/UserNotificationSetting');
const UserNotification = require('../src/db/models/UserNotification');
const NotificationTemplateService = require('../src/api/services/notificationTemplateService');
const RocketChatService = require('../src/api/services/rocketChatService');
const EmailService = require('../src/api/services/emailService');
const Project = require('../src/db/models/Project');

async function run(projectId) {
  try {
    const pid = projectId || 1;
    console.log('Simulating notifications for project_id=', pid);

    const project = await Project.findById(pid).catch(() => null);
    const projectObj = project || { id: pid, name: `#${pid}` };

    // fake created issue object
    const created = {
      id: Math.floor(Math.random() * 900000) + 100000,
      project_id: pid,
      title: 'Simulated issue from script',
      description: 'This is a test issue generated by simulate_issue_notifications.js'
    };

    const recipients = await UserNotificationSetting.getRecipientsForEvent(pid, 'issue_created');
    console.log('Recipients found:', recipients.length);
    if (!recipients || recipients.length === 0) return;

    const frontendRoot = process.env.FRONTEND_URL || '';
    const issueUrl = frontendRoot ? `${frontendRoot.replace(/\/$/, '')}/projects/${created.project_id}/issues/${created.id}` : '';

    const context = {
      project: projectObj,
      issue: created,
      actor: { id: 0, username: 'system' },
      issueUrl
    };

    for (const r of recipients) {
      try {
        // create center notification (non-blocking)
        try {
          const notifPayload = {
            user_id: r.user_id,
            event_code: 'issue_created',
            project_id: created.project_id,
            data: { issue: created, via: r.method_code }
          };
          UserNotification.create(notifPayload).catch((e) => console.error('Error creating user_notification', e && e.message));
        } catch (e) {
          console.error('Failed to queue user notification', e && e.message);
        }

        if (r.method_code === 'rocket_chat') {
          const rendered = await NotificationTemplateService.render('issue_created', 'rocket_chat', context);
          const textToSend = rendered.text || rendered.html || `${projectObj.name}: New issue #${created.id} - ${created.title}`;
          console.log('Sending Rocket.Chat to', r.rc_username || r.rc_user_id, 'text:', textToSend.slice(0, 120));
          const res = await RocketChatService.sendMessage({ channel: r.rc_username ? `@${r.rc_username}` : r.rc_user_id, text: textToSend });
          console.log(' -> result:', res && res.success);
        } else if (r.method_code === 'email') {
          const rendered = await NotificationTemplateService.render('issue_created', 'email', context);
          const subject = rendered.subject || `New issue #${created.id}`;
          console.log('Sending Email to', r.email, 'subject:', subject);
          const info = await EmailService.sendMail({ to: r.email, subject, text: rendered.text, html: rendered.html });
          console.log(' -> email sent:', !!info);
        } else {
          console.log('Unknown method for user', r.user_id, r.method_code);
        }
      } catch (err) {
        console.error('Error processing recipient', r.user_id, err && err.message ? err.message : err);
      }
    }

    console.log('Simulation finished');
  } catch (err) {
    console.error('Simulation error', err && err.stack ? err.stack : err);
    process.exit(2);
  }
}

if (require.main === module) {
  const pid = process.argv[2] ? Number(process.argv[2]) : 1;
  run(pid);
}

module.exports = { run };
